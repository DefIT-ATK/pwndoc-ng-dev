/**
 * Registry for custom vulnerability parsers with dependency management
 */
export class CustomVulnerabilityRegistry {
  constructor() {
    this.parsers = new Map()
    this.dependencies = new Map()
    this.fileTypeDefinitions = this.getFileTypeDefinitions()
    this.registerBuiltInParsers()
  }

  /**
   * Enhanced file type definitions with conditions, regex, and mandatory validation
   */
  getFileTypeDefinitions() {
    return {
      "Nessus": {
        description: "Nessus vulnerability scanner report",
        conditions: ["NessusClientData_v2", "nessus", "plugin_set", "bw_prevent_plugin_updates", 
                     "scan.enable_utf8_output", "compliance_generate_description"],
        extension: ".nessus",
        confidence: {
          extension: 80,    // Very high - .nessus is very specific
          conditions: 20,   // Lower since extension is so specific
          minScore: 50
        }
      },
      
      "PingCastle": {
        description: "PingCastle Active Directory security assessment report",
        conditions: ["GlobalScore", "MaturityLevel", "DomainFunctionalLevel", "HealthcheckDomainController", 
                     "DomainFQDN", "NumberOfDC"],
        extension: ".xml",
        mandatory: ["extension"]
      },
      
      "PurpleKnight": {
        description: "Purple Knight security assessment report",
        conditions: ["Purple Knight", "purpleknight"],
        extension: ".xlsx",
        filename: ["Security_Assessment_Report"],
        confidence: {
          extension: 20,    // .xlsx is common
          filename: 60,     // Filename is quite specific
          conditions: 20,   // Additional verification
          minScore: 40
        }
      },
      
      "SAM File": {
        description: "Windows SAM database dump",
        conditions: ["Administrator:500:aad3b435b51404eeaad3b435b51404ee", "Dumping SAM hashes", 
                     "SAM hashes to the database", "(Pwn3d!)"],
        extension: ".txt",
        confidence: {
          extension: 10,    // .txt is very common
          conditions: 90,   // Conditions are highly specific
          minScore: 50      // Require strong condition match
        }
      },
      
      "Cracked Passwords File": {
        description: "File containing cracked password hashes",
        conditions: [],
        extension: ".txt",
        // Regex to match the format domain\username:hash:password
        regex: /^[^\\]+\\[^:]+:[a-fA-F0-9]{32}:.+$/m,
        mandatory: ["regex"]
      },
      
      "NTDS Dump Enabled Users": {
        description: "NTDS dump file containing enabled users with password hashes",
        conditions: [],
        extension: ".txt",
        // Regex to match the format domain\username:6563:AAD3B435B51404EEAAD3B435B51404EE:E293EA6FD1DA433BAC7A556C1B064B03:::
        regex: /^[^\\]+\\[^:]+:[0-9]+:[a-fA-F0-9]{32}:[a-fA-F0-9]{32}:::$/m,
        filename: ["enabled_users_only_hashcat"],
        mandatory: ["regex"]
        // maybe add another list of "if we hit this, confidence = 100%"
      },
      
      "Domain Admins List": {
        description: "List of domain administrator accounts",
        conditions: [],
        extension: ".txt",
        filename: ["DA.txt", "domain_admins.txt"], // (or domain_admins.txt)
        mandatory: ["filename"]
      },
      
      "Domain Policy Info": {
        description: "Domain password policy information",
        conditions: [],
        extension: ".json",
        filename: ["domain_policy.json"],
        mandatory: ["filename"]
      },
      
      "Acunetix": {
        description: "Acunetix web vulnerability scanner report",
        conditions: ["acunetix", "vt_id", "vulnerabilities/acx", "acx"],
        extension: ".json",
        filename: ["_export.json"], // implement partial filename recognition TODO
        confidence: {
          extension: 10,    // Low weight since many JSON files exist
          filename: 20,     // Low weight since _export.json is generic
          conditions: 70,   // HIGH weight - this is the key differentiator
          minScore: 40      // Require strong condition match
        }
      },
      
      "ScoutSuite": {
        description: "ScoutSuite cloud security assessment report",
        conditions: ["all_subscriptions", "account_id", "aad", "storageaccounts"],
        extension: ".json",
        filename: ["_export.json"], // implement partial filename recognition TODO
        confidence: {
          extension: 10,    // Low weight since many JSON files exist
          filename: 20,     // Low weight since _export.json is generic  
          conditions: 70,   // HIGH weight - this is the key differentiator
          minScore: 40      // Require strong condition match
        }
      },
      
      "PowerUpSQL": {
        description: "PowerUpSQL database security assessment results",
        conditions: [],
        extension: ".csv",
        filename: ["PowerUpSQL_Audit_Results"],
        mandatory: ["filename"]
      }
    }
  }

  /**
   * Define dependency rules for custom vulnerability parsers
   * Currently disabled - focusing on file recognition only
   */
  getDependencyRules() {
    return {
      // Dependency rules disabled for now - focusing on file recognition
      // Will be re-enabled when implementing vulnerability associations
    }
  }

  /**
   * Register a custom vulnerability parser
   */
  registerParser(config) {
    const {
      name,
      displayName,
      description,
      dependencies = [],
      fileRequirements,
      parserClass,
      priority = 50,
      enabled = true
    } = config

    this.parsers.set(name, {
      name,
      displayName,
      description,
      dependencies,
      fileRequirements,
      parserClass,
      priority,
      enabled,
      type: 'custom'
    })

    // Register dependencies
    if (dependencies.length > 0) {
      this.dependencies.set(name, dependencies)
    }

    console.log(`Registered custom vulnerability parser: ${name}`)
  }

  /**
   * Check if all dependencies for a parser are available
   */
  canExecuteParser(parserName, availableFiles) {
    const parser = this.parsers.get(parserName)
    if (!parser || !parser.enabled) return false

    // Check if all required files are available
    return parser.fileRequirements.every(requirement => 
      this.checkFileRequirement(requirement, availableFiles)
    )
  }

  /**
   * Enhanced file requirement checking with conditions, regex, and mandatory validation
   */
  checkFileRequirement(requirement, availableFiles) {
    const { type, patterns, minCount = 1 } = requirement
    
    let matchingFiles = []
    
    switch (type) {
      case 'filename':
        matchingFiles = availableFiles.filter(file => 
          patterns.some(pattern => this.matchPattern(file.name, pattern))
        )
        break
        
      case 'content':
        // Check file contents (if content sample is available)
        matchingFiles = availableFiles.filter(file => 
          file.contentSample && patterns.some(pattern => 
            file.contentSample.toLowerCase().includes(pattern.toLowerCase())
          )
        )
        break
        
      case 'extension':
        matchingFiles = availableFiles.filter(file =>
          patterns.some(pattern => file.name.toLowerCase().endsWith(pattern.toLowerCase()))
        )
        break
        
      case 'regex':
        matchingFiles = availableFiles.filter(file => {
          return patterns.some(pattern => {
            try {
              const regex = new RegExp(pattern, 'i')
              return regex.test(file.name) || (file.contentSample && regex.test(file.contentSample))
            } catch (error) {
              console.warn('Invalid regex pattern:', pattern)
              return false
            }
          })
        })
        break

      case 'advanced': 
        // New advanced type for sophisticated file detection
        matchingFiles = availableFiles.filter(file => 
          this.checkAdvancedFileType(file, requirement)
        )
        break
    }
    
    return matchingFiles.length >= minCount
  }

  /**
   * Check file against advanced type definitions with conditions, regex, and mandatory rules
   */
  async checkAdvancedFileType(file, requirement) {
    const { fileType } = requirement
    const typeDef = this.fileTypeDefinitions[fileType]
    
    if (!typeDef) return false

    let score = 0
    const checks = []

    // Check extension
    if (typeDef.extension) {
      const hasCorrectExtension = file.name.toLowerCase().endsWith(typeDef.extension.toLowerCase())
      checks.push({ type: 'extension', passed: hasCorrectExtension, weight: 10 })
      if (hasCorrectExtension) score += 10
    }

    // Check filename patterns
    if (typeDef.filename) {
      const filenames = Array.isArray(typeDef.filename) ? typeDef.filename : [typeDef.filename]
      const matchesFilename = filenames.some(fn => 
        file.name.toLowerCase().includes(fn.toLowerCase()) ||
        this.matchPattern(file.name, fn)
      )
      checks.push({ type: 'filename', passed: matchesFilename, weight: 50 })
      if (matchesFilename) score += 50
    }

    // Read file content if needed for content checks
    let content = file.contentSample
    if (!content && (typeDef.conditions?.length > 0 || typeDef.regex || typeDef.mandatory?.includes('regex'))) {
      try {
        content = await this.readFileContent(file)
        file.contentSample = content // Cache for future use
      } catch (error) {
        console.warn('Could not read file content:', error)
        content = ''
      }
    }

    // Check conditions (grep-able strings)
    if (typeDef.conditions && typeDef.conditions.length > 0) {
      const conditionMatches = typeDef.conditions.filter(condition => 
        content.includes(condition)
      ).length
      const conditionScore = (conditionMatches / typeDef.conditions.length) * 30
      checks.push({ type: 'conditions', passed: conditionMatches > 0, weight: 30, matches: conditionMatches })
      score += conditionScore
    }

    // Check regex patterns
    if (typeDef.regex) {
      const regexMatch = typeDef.regex.test(content)
      checks.push({ type: 'regex', passed: regexMatch, weight: 40 })
      if (regexMatch) score += 40
    }

    // Check mandatory requirements
    if (typeDef.mandatory) {
      const mandatoryResults = typeDef.mandatory.map(req => {
        switch (req) {
          case 'regex':
            return typeDef.regex ? typeDef.regex.test(content) : true
          case 'filename':
            return typeDef.filename ? checks.find(c => c.type === 'filename')?.passed : true
          case 'conditions':
            return typeDef.conditions ? checks.find(c => c.type === 'conditions')?.passed : true
          default:
            return true
        }
      })
      
      const allMandatoryPassed = mandatoryResults.every(result => result)
      if (!allMandatoryPassed) {
        return false // Fail immediately if mandatory requirements not met
      }
    }

    // Return true if score is above threshold (adjust as needed)
    return score >= 20
  }

  /**
   * Read file content for analysis
   */
  async readFileContent(file) {
    return new Promise((resolve, reject) => {
      const reader = new FileReader()
      reader.onload = (e) => resolve(e.target.result)
      reader.onerror = (e) => reject(e)
      
      // Read first 10KB for analysis to avoid performance issues
      const blob = file.slice(0, 10240)
      reader.readAsText(blob)
    })
  }

  /**
   * Debug method to show detailed scoring for a specific file
   */
  async debugFileClassification(file) {
    console.log(`🔍 Debug classification for: ${file.name}`)
    const fileTypeDefinitions = this.getFileTypeDefinitions()
    
    const allScores = []
    for (const [fileType, definition] of Object.entries(fileTypeDefinitions)) {
      const result = await this._getFileTypeMatchScore(file, definition, fileType)
      allScores.push(result)
      
      console.log(`  ${fileType}: ${result.matches ? '✅' : '❌'} Score: ${Math.round(result.score)}`)
      if (result.details.checks.length > 0) {
        result.details.checks.forEach(check => {
          const status = check.passed ? '✓' : '✗'
          console.log(`    ${status} ${check.type}: +${Math.round(check.weight)}${check.matchedConditions ? ` (${check.matches}/${check.total} conditions)` : ''}`)
        })
      }
    }
    
    const matches = allScores.filter(s => s.matches)
    if (matches.length > 0) {
      const bestMatch = matches.reduce((best, current) => 
        current.score > best.score ? current : best
      )
      console.log(`🏆 Winner: ${bestMatch.fileType} (${Math.round(bestMatch.score)} points)`)
    } else {
      console.log(`❌ No matches found`)
    }
    
    return allScores
  }

  matchPattern(text, pattern) {
    // Convert glob pattern to regex
    const regex = new RegExp(pattern.replace(/\*/g, '.*').replace(/\?/g, '.'), 'i')
    return regex.test(text)
  }

  /**
   * Classify files and return classification results (focus on file recognition only)
   */
  async getClassifiedFiles(availableFiles) {
    const fileTypeDefinitions = this.getFileTypeDefinitions()
    
    console.log(`🔍 Analyzing ${availableFiles.length} files for type classification...`)
    
    // Classify all available files by type (async)
    const classifiedFiles = await this._classifyFiles(availableFiles, fileTypeDefinitions)
    
    console.log('📁 File Classification Results:')
    let totalClassified = 0
    const matchedFiles = []
    const unmatchedFiles = []
    
    // Track which files were matched
    const matchedFileNames = new Set()
    
    for (const [type, files] of Object.entries(classifiedFiles)) {
      if (files.length > 0) {
        console.log(`  ✓ ${type}: ${files.map(f => f.name).join(', ')}`)
        files.forEach(file => {
          matchedFiles.push({
            file,
            type,
            confidence: 'matched'
          })
          matchedFileNames.add(file.name)
        })
        totalClassified += files.length
      }
    }
    
    // Find unmatched files
    availableFiles.forEach(file => {
      if (!matchedFileNames.has(file.name)) {
        unmatchedFiles.push({
          file,
          type: 'Unknown',
          confidence: 'unmatched'
        })
      }
    })
    
    console.log(`📊 Classification Summary:`)
    console.log(`  ✅ Matched: ${matchedFiles.length} files`)
    console.log(`  ❓ Unmatched: ${unmatchedFiles.length} files`)
    
    return {
      classified: classifiedFiles,
      matched: matchedFiles,
      unmatched: unmatchedFiles,
      summary: {
        totalFiles: availableFiles.length,
        matchedCount: matchedFiles.length,
        unmatchedCount: unmatchedFiles.length
      }
    }
  }

  /**
   * Get all executable parsers for given files using dependency system (async)
   * Currently disabled - focusing on file recognition only
   */
  async getExecutableParsers(availableFiles) {
    // For now, just return file classification results
    const result = await this.getClassifiedFiles(availableFiles)
    
    // Return empty parsers array since we're focusing on file recognition
    return []
  }

  /**
   * Classify available files by their detected types (async for content analysis)
   * Uses best-match algorithm to handle overlapping filename patterns
   */
  async _classifyFiles(availableFiles, fileTypeDefinitions) {
    const classified = {}
    
    // Initialize all file types
    for (const fileType of Object.keys(fileTypeDefinitions)) {
      classified[fileType] = []
    }
    
    // For each file, find the BEST matching type (not first match)
    for (const file of availableFiles) {
      try {
        const matchResults = []
        
        // Test file against ALL type definitions and collect scores
        for (const [fileType, definition] of Object.entries(fileTypeDefinitions)) {
          const matchResult = await this._getFileTypeMatchScore(file, definition, fileType)
          if (matchResult.matches) {
            matchResults.push(matchResult)
          }
        }
        
        // Pick the best match (highest confidence score)
        if (matchResults.length > 0) {
          const bestMatch = matchResults.reduce((best, current) => 
            current.score > best.score ? current : best
          )
          
          console.log(`📄 File ${file.name} best match: ${bestMatch.fileType} (score: ${Math.round(bestMatch.score)})`)
          if (matchResults.length > 1) {
            console.log(`  🔍 Other candidates: ${matchResults
              .filter(m => m.fileType !== bestMatch.fileType)
              .map(m => `${m.fileType}(${Math.round(m.score)})`)
              .join(', ')}`)
          }
          
          classified[bestMatch.fileType].push(file)
        }
      } catch (error) {
        console.warn(`Error classifying file ${file.name}:`, error.message)
      }
    }
    
    return classified
  }

  /**
   * Get detailed match score for a file against a specific type definition
   * Returns: { matches: boolean, score: number, fileType: string, details: object }
   */
  async _getFileTypeMatchScore(file, definition, fileType) {
    let score = 0
    const checks = []
    
    // Check extension(s)
    if (definition.extension) {
      const extensions = Array.isArray(definition.extension) ? definition.extension : [definition.extension]
      const hasCorrectExtension = extensions.some(ext => 
        file.name.toLowerCase().endsWith(ext.toLowerCase())
      )
      const extensionScore = definition.confidence?.extension || 20
      checks.push({ type: 'extension', passed: hasCorrectExtension, weight: extensionScore })
      if (hasCorrectExtension) score += extensionScore
    }
    
    // Check filename patterns
    if (definition.filename) {
      const filenames = Array.isArray(definition.filename) ? definition.filename : [definition.filename]
      const matchesFilename = filenames.some(fn => {
        const fileName = file.name.toLowerCase()
        const pattern = fn.toLowerCase()
        
        // Exact match (highest confidence)
        if (fileName === pattern || fileName === `${pattern}.txt` || fileName === `${pattern}.json` || fileName === `${pattern}.csv`) {
          return true
        }
        
        // Contains match
        return fileName.includes(pattern) || this.matchPattern(fileName, pattern)
      })
      
      const filenameScore = definition.confidence?.filename || 50
      checks.push({ type: 'filename', passed: matchesFilename, weight: filenameScore })
      if (matchesFilename) score += filenameScore
    }
    
    // Read file content if needed for advanced checks
    let content = file.contentSample
    if (!content && (definition.conditions?.length > 0 || definition.regex || definition.mandatory?.length > 0)) {
      try {
        content = await this.readFileContent(file)
        file.contentSample = content // Cache for future use
      } catch (error) {
        console.warn(`Could not read file content for ${file.name}:`, error.message)
        content = ''
      }
    }
    
    // Check conditions (grep-able strings) - THIS IS KEY FOR DISTINGUISHING ACUNETIX VS SCOUTSUITE
    if (definition.conditions && definition.conditions.length > 0) {
      const conditionMatches = definition.conditions.filter(condition => 
        content.toLowerCase().includes(condition.toLowerCase())
      )
      const conditionRatio = conditionMatches.length / definition.conditions.length
      const conditionScore = (definition.confidence?.conditions || 30) * conditionRatio
      checks.push({ 
        type: 'conditions', 
        passed: conditionMatches.length > 0, 
        weight: conditionScore,
        matches: conditionMatches.length,
        total: definition.conditions.length,
        matchedConditions: conditionMatches
      })
      score += conditionScore
    }
    
    // Check regex patterns
    if (definition.regex) {
      const regexMatch = definition.regex.test(content)
      const regexScore = definition.confidence?.regex || 40
      checks.push({ type: 'regex', passed: regexMatch, weight: regexScore })
      if (regexMatch) score += regexScore
    }
    
    // Validate mandatory requirements
    let mandatoryPassed = true
    if (definition.mandatory && definition.mandatory.length > 0) {
      const mandatoryResults = definition.mandatory.map(req => {
        switch (req) {
          case 'regex':
            return definition.regex ? definition.regex.test(content) : true
          case 'filename':
            return definition.filename ? checks.find(c => c.type === 'filename')?.passed : true
          case 'extension':
            return definition.extension ? checks.find(c => c.type === 'extension')?.passed : true
          case 'conditions':
            return definition.conditions ? checks.find(c => c.type === 'conditions')?.passed : true
          default:
            console.warn(`Unknown mandatory requirement: ${req}`)
            return true
        }
      })
      
      mandatoryPassed = mandatoryResults.every(result => result)
      if (!mandatoryPassed) {
        console.log(`File ${file.name} failed mandatory requirements for ${fileType}`)
        return { matches: false, score: 0, fileType, details: { checks, mandatoryPassed } }
      }
    }
    
    // Determine minimum score threshold (adjustable)
    const minScore = definition.confidence?.minScore || 20
    const matches = score >= minScore && mandatoryPassed
    
    return {
      matches,
      score,
      fileType,
      details: {
        checks,
        mandatoryPassed,
        minScore,
        description: definition.description
      }
    }
  }

  /**
   * Check if a file matches a specific file type definition with confidence scoring
   * @deprecated - Use _getFileTypeMatchScore instead for better scoring
   */
  async _matchesFileTypeDefinition(file, definition) {
    let score = 0
    const checks = []
    
    // Check extension(s)
    if (definition.extension) {
      const extensions = Array.isArray(definition.extension) ? definition.extension : [definition.extension]
      const hasCorrectExtension = extensions.some(ext => 
        file.name.toLowerCase().endsWith(ext.toLowerCase())
      )
      const extensionScore = definition.confidence?.extension || 20
      checks.push({ type: 'extension', passed: hasCorrectExtension, weight: extensionScore })
      if (hasCorrectExtension) score += extensionScore
    }
    
    // Check filename patterns
    if (definition.filename) {
      const filenames = Array.isArray(definition.filename) ? definition.filename : [definition.filename]
      const matchesFilename = filenames.some(fn => {
        const fileName = file.name.toLowerCase()
        const pattern = fn.toLowerCase()
        
        // Exact match (highest confidence)
        if (fileName === pattern || fileName === `${pattern}.txt` || fileName === `${pattern}.json`) {
          return true
        }
        
        // Contains match
        return fileName.includes(pattern) || this.matchPattern(fileName, pattern)
      })
      
      const filenameScore = definition.confidence?.filename || 50
      checks.push({ type: 'filename', passed: matchesFilename, weight: filenameScore })
      if (matchesFilename) score += filenameScore
    }
    
    // Read file content if needed for advanced checks
    let content = file.contentSample
    if (!content && (definition.conditions?.length > 0 || definition.regex || definition.mandatory?.length > 0)) {
      try {
        content = await this.readFileContent(file)
        file.contentSample = content // Cache for future use
      } catch (error) {
        console.warn(`Could not read file content for ${file.name}:`, error.message)
        content = ''
      }
    }
    
    // Check conditions (grep-able strings)  
    if (definition.conditions && definition.conditions.length > 0) {
      const conditionMatches = definition.conditions.filter(condition => 
        content.toLowerCase().includes(condition.toLowerCase())
      )
      const conditionRatio = conditionMatches.length / definition.conditions.length
      const conditionScore = (definition.confidence?.conditions || 30) * conditionRatio
      checks.push({ 
        type: 'conditions', 
        passed: conditionMatches.length > 0, 
        weight: conditionScore,
        matches: conditionMatches.length,
        total: definition.conditions.length
      })
      score += conditionScore
    }
    
    // Check regex patterns
    if (definition.regex) {
      const regexMatch = definition.regex.test(content)
      const regexScore = definition.confidence?.regex || 40
      checks.push({ type: 'regex', passed: regexMatch, weight: regexScore })
      if (regexMatch) score += regexScore
    }
    
    // Validate mandatory requirements
    if (definition.mandatory && definition.mandatory.length > 0) {
      const mandatoryResults = definition.mandatory.map(req => {
        switch (req) {
          case 'regex':
            return definition.regex ? definition.regex.test(content) : true
          case 'filename':
            return definition.filename ? checks.find(c => c.type === 'filename')?.passed : true
          case 'extension':
            return definition.extension ? checks.find(c => c.type === 'extension')?.passed : true
          case 'conditions':
            return definition.conditions ? checks.find(c => c.type === 'conditions')?.passed : true
          default:
            console.warn(`Unknown mandatory requirement: ${req}`)
            return true
        }
      })
      
      const allMandatoryPassed = mandatoryResults.every(result => result)
      if (!allMandatoryPassed) {
        console.log(`File ${file.name} failed mandatory requirements for ${definition.description || 'unknown type'}`)
        return false // Fail immediately if mandatory requirements not met
      }
    }
    
    // Determine minimum score threshold (adjustable)
    const minScore = definition.confidence?.minScore || 30
    const passed = score >= minScore
    
    if (passed) {
      console.log(`✓ File ${file.name} matched type (score: ${Math.round(score)})`)
      if (checks.length > 0) {
        checks.forEach(check => {
          if (check.passed) {
            console.log(`  ✓ ${check.type}: +${Math.round(check.weight)}`)
          }
        })
      }
    }
    
    return passed
  }

  getMatchingFiles(parser, availableFiles) {
    const matching = {}
    
    parser.fileRequirements.forEach((requirement, index) => {
      const files = availableFiles.filter(file => 
        this.checkFileRequirement(requirement, [file])
      )
      matching[`requirement_${index}`] = files
    })
    
    return matching
  }

  /**
   * Get all registered parsers
   */
  getAllParsers() {
    return Array.from(this.parsers.values())
  }

  /**
   * Enable/disable a parser
   */
  setParserEnabled(parserName, enabled) {
    const parser = this.parsers.get(parserName)
    if (parser) {
      parser.enabled = enabled
      console.log(`Parser ${parserName} ${enabled ? 'enabled' : 'disabled'}`)
    }
  }

  /**
   * Register built-in custom parsers
   * Currently disabled - focusing on file recognition only
   */
  registerBuiltInParsers() {
    console.log('Built-in parser registration disabled - focusing on file recognition only')
    // Parser registration will be re-enabled when implementing vulnerability associations
  }
}

// Singleton instance
export const customVulnRegistry = new CustomVulnerabilityRegistry()
